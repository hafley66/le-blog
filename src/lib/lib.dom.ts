import {
  filter,
  fromEvent,
  map,
  Observable,
  pairwise,
  scan,
  share,
  shareReplay,
  startWith,
  tap,
} from "rxjs"
import jsx from "~/lib/rxjs-vhtml/v2/jsx-runtime"
import {
  HtmlEvent,
  HEvents,
  HtmlEventIndex$,
} from "./rxjs-vhtml/v2/types.dom.events.dom"

/**
 * This was copied pasted from my own personal lib,
 * this and my variant of useObservable are my personal variants of using rxjs with react,
 * sorry if this seems autogenerated, i've used this __alot__
 */
/**
 * Creates an observable that emits events of a specific type from elements matching a selector.
 * Basically jQuery style event delegation with precise selectors. This kinda falls apart when you are mapping over elements in rxjs+react,
 * rxjs is only good at singletons in react.
 *
 * @example
 * const buttonClicks = fromEventDelegate("button", "click");
 *
 * buttonClicks.subscribe(event => {
 *   console.log("Button clicked:", event);
 * });
 */
export function fromEventDelegate<
  K extends keyof HTMLElementEventMap,
>(
  selector: string,
  eventName: K,
  root = document.body,
): Observable<HTMLElementEventMap[K]> {
  return fromEvent<HTMLElementEventMap[K]>(
    root,
    eventName,
  ).pipe(
    filter(event => {
      const target = event.target as HTMLElement
      return target?.matches(selector)
    }),
  )
}
export interface TaggedComponent<
  T extends string | ((...args: any[]) => any),
  Selector extends string = "",
> {
  (
    props: T extends (...args: any[]) => any
      ? Parameters<T>[0]
      : any,
  ): Observable<string>
  selector: Selector
  $: HtmlEventIndex$
}

export function withSelector<
  T extends string | ((...args: any[]) => any),
  ClassName extends string = "",
>(
  Tag: T,
  selector: ClassName,
): TaggedComponent<T, ClassName> {
  const it = (
    props: T extends (...args: any[]) => any
      ? Parameters<T>[0]
      : any,
  ) => {
    return jsx(Tag, {
      ...props,
      ...(selector.startsWith(".")
        ? {
            className: [
              selector.replace(".", ""),
              props.className,
            ],
          }
        : selector.startsWith("#")
          ? {
              id: selector.replace("#", ""),
            }
          : {}),
    })
  }

  it.selector = selector
  const eventStreamCache = {} as Record<string, any>

  it.$ = new Proxy(eventStreamCache, {
    get(target, p: HtmlEvent, receiver) {
      if (p in target) return target[p]
      // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
      return (eventStreamCache[p] ||= fromEventDelegate(
        selector,
        p as HtmlEvent,
      )).pipe(share())
    },
  }) as unknown as HtmlEventIndex$

  return it
}
export function withClass<
  T extends string | ((...args: any[]) => any),
  ID extends string = "",
>(
  Tag: T,
  className: ID,
): TaggedComponent<T, `#${ID}`> & { className: ID } {
  const it = withSelector(Tag, `.${className}`)
  // @ts-ignore
  it.className = className
  // @ts-ignore
  return it
}

export function withId<
  T extends string | ((...args: any[]) => any),
  ID extends string = "",
>(
  Tag: T,
  id: ID,
): TaggedComponent<T, `#${ID}`> & { id: ID } {
  const it = withSelector(Tag, `#${id}`)
  // @ts-ignore
  it.id = id
  // @ts-ignore
  return it
}

export function fromInputDelegate(selector: string) {
  return fromEventDelegate(selector, "input").pipe(
    map(e => (e.target as HTMLInputElement).value),
  )
}

/**
 * Creates an observable that emits the numeric value of an input element.
 *
 * @param selector The selector of the input element.
 * @param defaultValue The default value to emit if the input element's value is not available. Defaults to `undefined`.
 * @returns An observable that emits the numeric value of the input element.
 *
 * @example
 * const inputNumber = fromInputNumber("#myInput", 0);
 *
 * inputNumber.subscribe(value => {
 *   console.log("Input value:", value);
 * });
 */
export function fromInputNumber(
  selector: string,
  defaultValue?: number,
) {
  return fromEventDelegate(selector, "input").pipe(
    map(e => +(e.target as HTMLInputElement).value),
    startWith(defaultValue),
    tap(console.log),
  )
}

export const mouseMove$ = fromEvent<MouseEvent>(
  document,
  "mousemove",
).pipe(
  map(e => ({
    x: e.clientX,
    y: e.clientY,
    timestamp: e.timeStamp,
  })),
  pairwise(),
  map(([prev, curr]) => {
    const dt = curr.timestamp - prev.timestamp
    return {
      x: (curr.x - prev.x) / dt,
      y: (curr.y - prev.y) / dt,
      currentX: curr.x,
      currentY: curr.y,
    }
  }),
  scan(
    (acc, curr) => ({
      x: acc.x * 0.8 + curr.x * 0.2,
      y: acc.y * 0.8 + curr.y * 0.2,
      currentX: curr.currentX,
      currentY: curr.currentY,
    }),
    { x: 0, y: 0, currentX: 0, currentY: 0 },
  ),
  startWith({ x: 0, y: 0, currentX: 0, currentY: 0 }),
  shareReplay({ refCount: true, bufferSize: 1 }),
)

export type HTMLElementEventMapCopy = HTMLElementEventMap
